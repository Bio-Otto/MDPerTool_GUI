#######################################################################################################################
##################################### This script was generated by MDPerTool v0.1 #####################################
#######################################################################################################################
from no_gui.get_positions_from_trajectory_file import *
from no_gui.energy_decomposition_from_trajectory import *
from no_gui.response_time_creator import *
from no_gui.Velocity_Changer import *
from no_gui.response_time_creator import *
from no_gui.apply_pdbfixer import fix_pdb
from no_gui.write_outputs import *

from openmm import unit
from openmm import *
from openmm import app
from openmm.app import PME, NoCutoff, Ewald, CutoffPeriodic, CutoffNonPeriodic, HBonds, HAngles, AllBonds,DCDReporter
import openmm as mm
from openmm.unit import femtosecond, picosecond, nanometer, kelvin, angstrom, atmospheres

from sys import stdout
import platform as pl
import time
import argparse
import multiprocessing as mp
from pathlib import Path, PureWindowsPath
from mdtraj import reporters
from mdtraj.reporters import XTCReporter


#######################################################################################################################
###################################### CLASSICAL MD PROCESS USING MDPerTool v0.1 ######################################
#######################################################################################################################

simulation_last_time = 0
print('pdb file fixing and preparing for simulation ...')
fixed_pdb_name = fix_pdb('{{pdb}}', fixed_pdb_out_path='{{output_folder}}')

print('Loading pdb to simulation engine ...')
pdb = app.PDBFile(fixed_pdb_name)

box = pdb.topology.getUnitCellDimensions()

print('Modeller of pdb file is preparing ...')
modeller = mm.app.Modeller(pdb.topology, pdb.positions)
modeller.topology.setUnitCellDimensions(box)

print('Forcefield parameters loading to the simulation system ...')
forcefield = app.ForceField('{{protein_ff}}'{{#water_active}}, '{{water_ff}}'{{/water_active}})

print('Adding missing hydrogens to the model ...')
modeller.addHydrogens(forcefield)

print('Adding solvent (both water and ions) to the model to fill a rectangular box ...')
modeller.addSolvent(forcefield, model='{{model_water}}', padding={{water_padding}})

print('Constructing an OpenMM System')
system = forcefield.createSystem(modeller.topology, nonbondedMethod={{NonBoundedMethod}},
                                      {{#Nonbounded_cutoff_active}}nonbondedCutoff={{NonBounded_cutoff}},{{/Nonbounded_cutoff_active}}
                                      constraints={{Constraints}}, rigidWater={{Rigid_Water}},
                                      ewaldErrorTolerance=0.005)

system.addForce(mm.MonteCarloBarostat(1 * atmospheres, {{Temperature}}, 25))

{{#use_switching_distance}}
nonbonded = [f for f in system.getForces() if isinstance(f, NonbondedForce)][0]
nonbonded.setUseSwitchingFunction(use=True)
nonbonded.setSwitchingDistance({{switching_distance}})
nonbonded.setUseDispersionCorrection(True)
{{/use_switching_distance}}

print('Creating a %sIntegrator with %s %s .' %('{{integrator_kind}}', {{integrator_time_step}}, '{{integrator_time_step_unit}}'))
integrator = mm.{{integrator_kind}}Integrator({{#Additional_Integrator}}{{Temperature}}, {{friction}}, {{/Additional_Integrator}}{{integrator_time_step}}*{{integrator_time_step_unit}})

if {{cuda_active}} == True:
    platform = mm.Platform.getPlatformByName('{{platform}}')
    {{#properties_active}}properties = {'{{cuda_precision_prefix}}Precision': '{{precision}}'{{#Device_ID_active}},'{{cuda_precision_prefix}}DeviceIndex': '{{Device_Number}}'{{/Device_ID_active}}}{{/properties_active}}
else:
    platform = mm.Platform.getPlatformByName('{{platform}}')
    {{#properties_active}}properties = {'{{platform}}Precision': '{{precision}}'{{#Device_ID_active}},'{{platform}}DeviceIndex': '{{Device_Number}}'{{/Device_ID_active}}}{{/properties_active}}

{{#CPU_properties_active}}properties = {'CpuThreads': '{{Number_of_CPU}}'}{{/CPU_properties_active}}

simulation = app.Simulation(modeller.topology, system, integrator, platform{{#properties_active}}, properties{{/properties_active}})
simulation.context.setPositions(modeller.positions)
simulation.context.computeVirtualSites()

{{#Minimize}}
print('Minimizing for %s steps ...' % {{Max_minimization_iteration}})
simulation.minimizeEnergy({{#no_minimize_value}}maxIterations=int({{Max_minimization_iteration}}){{/no_minimize_value}})
print("Minimization done, the energy is", simulation.context.getState(getEnergy=True).getPotentialEnergy())
positions = simulation.context.getState(getPositions=True).getPositions()
print("Minimized geometry is written to 'minimized.pdb'")
app.PDBFile.writeModel(modeller.topology, positions, open('{{output_folder}}/minimized.pdb', 'w'), keepIds=True){{/Minimize}}

simulation.context.setVelocitiesToTemperature({{Temperature}})

{{#Equilubrate}}
print('Equilibrating for %s steps ...' % {{Equilubrate_steps}})
simulation.step(int({{Equilubrate_steps}}))
{{/Equilubrate}}

simulation.currentStep = simulation_last_time

{{#DCDReporter}}
print('The trajectories will be saved in DCD file format.')
print("Saving DCD File for every {{DCD_write_freq}} period")
simulation.reporters.append(DCDReporter('{{output_folder}}/{{DCD_output_name}}', {{DCD_write_freq}}))
{{/DCDReporter}}

{{#XTCReporter}}
print('The trajectories will be saved in XTC file format.')
print("Saving XTC File for every {{XTC_write_freq}} period")
simulation.reporters.append(reporters.XTCReporter('{{output_folder}}/{{XTC_output_name}}', {{XTC_write_freq}}))
{{/XTCReporter}}

{{#State_Data_Reporter}}
print('State Report will tell you.')
simulation.reporters.append(StateDataReporter(stdout, {{StateData_freq}}, step=True,
time=True, potentialEnergy=True, kineticEnergy=True, totalEnergy=True, temperature=True, progress=True,
remainingTime=True, speed=True, volume=True, density=True, totalSteps={{Number_of_steps}}))
{{/State_Data_Reporter}}

print('Running Production...')
simulation.step({{Number_of_steps}})
print('Done!')

lastpositions = simulation.context.getState(getPositions=True).getPositions()

last_pdb = app.PDBFile.writeFile(modeller.topology, lastpositions, open('{{output_folder}}/last.pdb', 'w'), keepIds=True)


state = simulation.context.getState(getPositions=True, getVelocities=True)

with open('{{output_folder}}/system.xml', 'w') as f:
    system_xml = mm.XmlSerializer.serialize(system)
    f.write(system_xml)

with open('{{output_folder}}/integrator.xml', 'w') as f:
    integrator_xml = mm.XmlSerializer.serialize(integrator)
    f.write(integrator_xml)

with open('{{output_folder}}/state.xml', 'w') as f:
    f.write(mm.XmlSerializer.serialize(state))

#simulation.context.setTime(0)

#######################################################################################################################
#################################### PERTURBATION MD PROCESS USING MDPerTool v0.1 #####################################
#######################################################################################################################
# ## --> VARIABLES
simulation_last_step = simulation.currentStep
print("LAST TIME", simulation_last_time)
state_file_name = 'state.xml'
last_pdb = 'last.pdb'
dissipated_trajectory_name = 'energy_perturbation_trajectory'
undissipated_trajectory_name = 'without_energy_perturbation_trajectory'
reference_traj_file_for_pos = str
dissipation_traj_file_for_pos = str
OUTPUT_DIRECTORY = str
created_file_for_work = str
OUTPUT_FOLDER_NAME = str


OUTPUT_DIRECTORY = Path('{{output_folder}}')

last_pdb_file_path = os.path.join(OUTPUT_DIRECTORY, last_pdb)
modify_atoms = convert_res_to_atoms(last_pdb_file_path, {{{perturbed_res_list}}}, 'CA')
state_file_path = os.path.join(OUTPUT_DIRECTORY, state_file_name)

print("SPEED LIST: ", {{speed_factor}})

for i in range(len({{speed_factor}})):
    name_of_changed_state_xml = change_velocity(state_file_path, {{speed_factor}}[i], modify_atoms)
    new_dissipated_trajectory_name = dissipated_trajectory_name + str({{speed_factor}}[i])

    if {{DCDReporter}} == False and {{XTCReporter}} == False:
        write_dcd_cond = True

    if i == 0:

        ################################################################################################################
        ################################ REFERENCE MD PROCESS USING MDPerTool v0.1 #####################################
        ################################################################################################################
        if '{{platform}}' == 'OpenCL' and {{Device_ID_active}} == True:
            properties = {'OpenCLPrecision': 'double', 'OpenCLDeviceIndex': '{{Device_Number}}'}
            precision = 'double'

        if '{{platform}}' == 'OpenCL' and {{Device_ID_active}} == False:
            properties = {'OpenCLPrecision': 'double'}
            precision = 'double'

        if '{{platform}}' == 'CUDA' and {{Device_ID_active}} == True:
            properties = {'CudaPrecision': 'double', 'CudaDeviceIndex': '{{Device_Number}}'}
            precision = 'double'

        if '{{platform}}' == 'CUDA' and {{Device_ID_active}} == False:
            properties = {'CudaPrecision': 'double'}
            precision = 'double'

        if '{{platform}}' == 'CPU' and {{CPU_properties_active}} == True:
            print("The CPU platform always uses 'mixed' precision.")
            print("Simulation process will use %s Thread(s)" % {{Number_of_CPU}})
            properties = {'CpuThreads': '{{Number_of_CPU}}'}
            precision = 'mixed'

        if '{{platform}}' == 'Reference':
            print("The Reference platform always uses 'double' precision.")
            properties = None
            precision= 'double'

        # we'll just take the topology from here...
        pdb = app.PDBFile(last_pdb_file_path)
        topology = pdb.topology

        print('Forcefield parameters loading to the simulation system ...')
        forcefield = app.ForceField('{{protein_ff}}', '{{water_ff}}')

        print('Constructing an OpenMM System')
        reference_system = forcefield.createSystem(topology, nonbondedMethod=app.PME, nonbondedCutoff={{NonBounded_cutoff}},
                                                   constraints=None, rigidWater=True, ewaldErrorTolerance=1e-5)

        if {{use_switching_distance}} == True:
            print("System will use Switching Distance")
            nonbonded = [f for f in reference_system.getForces() if isinstance(f, NonbondedForce)][0]
            nonbonded.setUseSwitchingFunction(use=True)
            nonbonded.setSwitchingDistance({{switching_distance}})

        integrator = VerletIntegrator(1.0*femtosecond)
        integrator.setConstraintTolerance(1e-8)

        # let's specify our simulation platform again
        platform = mm.Platform.getPlatformByName('{{platform}}')

        # ok now let's do some simulation using this restraint
        if properties is None:
            ref_simulation = app.Simulation(topology, reference_system, integrator, platform)

        if properties is not None:
            ref_simulation = app.Simulation(topology, reference_system, integrator, platform, properties)

        ref_simulation.loadState(state_file_path)
        final_state = ref_simulation.context.getState(getVelocities=True, getPositions=True)
        positions = final_state.getPositions()
        velocities = final_state.getVelocities()
        ref_simulation.context.setPositions(positions)
        ref_simulation.context.computeVirtualSites()
        ref_simulation.context.setVelocities(velocities)
        print("USES OR NOT: %s" % reference_system.usesPeriodicBoundaryConditions())

        ref_simulation.currentStep = simulation_last_step

        if pl.system() == 'Windows':
            print("Saving XTC File for every 1 period")
            XTC_file_path = os.path.join(OUTPUT_DIRECTORY, '%s.xtc' % undissipated_trajectory_name)
            ref_simulation.reporters.append(XTCReporter(XTC_file_path, 1))

        else:
            if {{DCDReporter}} == False and {{XTCReporter}} == False:
                print("Saving DCD File for every 1 period")
                DCD_file_path = os.path.join(OUTPUT_DIRECTORY, '%s.dcd' % undissipated_trajectory_name)
                ref_simulation.reporters.append(app.DCDReporter(DCD_file_path, 1))

            if {{DCDReporter}} == True:
                print("Saving DCD File for every 1 period")
                DCD_file_path = os.path.join(OUTPUT_DIRECTORY, '%s.dcd' % undissipated_trajectory_name)
                ref_simulation.reporters.append(app.DCDReporter(DCD_file_path, 1))

            if {{XTCReporter}} == True:
                print("Saving XTC File for every 1 period")
                XTC_file_path = os.path.join(OUTPUT_DIRECTORY, '%s.xtc' % undissipated_trajectory_name)
                ref_simulation.reporters.append(XTCReporter(XTC_file_path, 1))

        {{#State_Data_Reporter}}
        print('State Report will tell you.')
        ref_simulation.reporters.append(StateDataReporter(stdout, 1, step=True, time=True, potentialEnergy=True,
                                  kineticEnergy=True, totalEnergy=True, temperature=True, progress=True, volume=True,
                                  density=True, remainingTime=True, speed=True, totalSteps={{perturb_simulation_time}}))
        {{/State_Data_Reporter}}

        ref_simulation.step({{perturb_simulation_time}})

        simulation_last_step = ref_simulation.currentStep

    ################################################################################################################
    ############################### DISSIPATION MD PROCESS USING MDPerTool v0.1 ####################################
    ################################################################################################################

    if '{{platform}}' == 'OpenCL' and {{Device_ID_active}} == True:
        properties = {'OpenCLPrecision': 'double', 'OpenCLDeviceIndex': '{{Device_Number}}'}
        precision = 'double'

    if '{{platform}}' == 'OpenCL' and {{Device_ID_active}} == False:
        properties = {'OpenCLPrecision': 'double'}
        precision = 'double'

    if '{{platform}}' == 'CUDA' and {{Device_ID_active}} == True:
        properties = {'CudaPrecision': 'double', 'CudaDeviceIndex': '{{Device_Number}}'}
        precision = 'double'

    if '{{platform}}' == 'CUDA' and {{Device_ID_active}} == False:
        properties = {'CudaPrecision': 'double'}
        precision = 'double'

    if '{{platform}}' == 'CPU' and {{CPU_properties_active}} == True:
        print("The CPU platform always uses 'mixed' precision.")
        print("Simulation process will use %s Thread(s)" % {{Number_of_CPU}})
        properties = {'CpuThreads': '{{Number_of_CPU}}'}
        precision = 'mixed'

    if '{{platform}}' == 'Reference':
        print("The Reference platform always uses 'double' precision.")
        properties = None
        precision= 'double'

    print("System will use %s Platform with %s Precision" % ('{{platform}}', precision))

    # we'll just take the topology from here...
    pdb = app.PDBFile(last_pdb_file_path)
    topology = pdb.topology

    print('Forcefield parameters loading to the simulation system ...')
    forcefield = app.ForceField('{{protein_ff}}', '{{water_ff}}')

    print('Constructing an OpenMM System')
    perturbed_system = forcefield.createSystem(topology, nonbondedMethod=app.PME, nonbondedCutoff={{NonBounded_cutoff}},
                                               constraints=None, rigidWater=True, ewaldErrorTolerance=1e-5)

    if {{use_switching_distance}} == True:
        print("System will use Switching Distance")
        nonbonded = [f for f in perturbed_system.getForces() if isinstance(f, NonbondedForce)][0]
        nonbonded.setUseSwitchingFunction(use=True)
        nonbonded.setSwitchingDistance({{switching_distance}})

    integrator = VerletIntegrator(1.0*femtosecond)
    integrator.setConstraintTolerance(1e-8)

    # let's specify our simulation platform again
    platform = mm.Platform.getPlatformByName('{{platform}}')

    # ok now let's do some simulation using this restraint
    if properties is None:
        simulation = app.Simulation(topology, perturbed_system, integrator, platform)

    if properties is not None:
        simulation = app.Simulation(topology, perturbed_system, integrator, platform, properties)

    simulation.loadState(name_of_changed_state_xml)
    final_state = simulation.context.getState(getVelocities=True, getPositions=True)
    positions = final_state.getPositions()
    velocities = final_state.getVelocities()
    simulation.context.setPositions(positions)
    simulation.context.computeVirtualSites()
    simulation.context.setVelocities(velocities)
    print("USES OR NOT: %s" % perturbed_system.usesPeriodicBoundaryConditions())

    simulation.currentStep = simulation_last_step

    if pl.system() == 'Windows':
        print("Saving XTC File for every 1 period")
        XTC_file_path = os.path.join(OUTPUT_DIRECTORY, '%s.xtc' % new_dissipated_trajectory_name)
        simulation.reporters.append(XTCReporter(XTC_file_path, 1))

    else:
        if {{DCDReporter}} == False and {{XTCReporter}} == False:
            print("Saving DCD File for every 1 period")
            DCD_file_path = os.path.join(OUTPUT_DIRECTORY, '%s.dcd' % new_dissipated_trajectory_name)
            simulation.reporters.append(app.DCDReporter(DCD_file_path, 1))

        if {{DCDReporter}} == True:
            print("Saving DCD File for every 1 period")
            DCD_file_path = os.path.join(OUTPUT_DIRECTORY, '%s.dcd' % new_dissipated_trajectory_name)
            simulation.reporters.append(app.DCDReporter(DCD_file_path, 1))

        if {{XTCReporter}} == True:
            print("Saving XTC File for every 1 period")
            XTC_file_path = os.path.join(OUTPUT_DIRECTORY, '%s.xtc' % new_dissipated_trajectory_name)
            simulation.reporters.append(XTCReporter(XTC_file_path, 1))

    {{#State_Data_Reporter}}
    print('State Report will tell you.')
    simulation.reporters.append(StateDataReporter(stdout, 1, step=True, time=True, potentialEnergy=True,
                              kineticEnergy=True, totalEnergy=True, temperature=True, progress=True, volume=True,
                              density=True, remainingTime=True, speed=True, totalSteps={{perturb_simulation_time}}))
    {{/State_Data_Reporter}}

    simulation.step({{perturb_simulation_time}})

    simulation_last_step = simulation.currentStep

    ################################################################################################################
    ############################# PER RESIDUE ENERGY CALCULATION USING MDPerTool v0.1 ##############################
    ################################################################################################################
    if pl.system() == 'Windows':
        print("Decompose started using XTC File ...")
        reference_traj_file_for_pos = os.path.join(OUTPUT_DIRECTORY, undissipated_trajectory_name + '.xtc')
        dissipation_traj_file_for_pos = os.path.join(OUTPUT_DIRECTORY, new_dissipated_trajectory_name + '.xtc')

    else:
        if {{DCDReporter}} == False and {{XTCReporter}} == False:
            print("Decompose started using DCD File")
            reference_traj_file_for_pos = os.path.join(OUTPUT_DIRECTORY, undissipated_trajectory_name + '.dcd')
            dissipation_traj_file_for_pos = os.path.join(OUTPUT_DIRECTORY, new_dissipated_trajectory_name + '.dcd')

        if {{DCDReporter}} == True:
            print("Decompose started using DCD File")
            reference_traj_file_for_pos = os.path.join(OUTPUT_DIRECTORY, undissipated_trajectory_name + '.dcd')
            dissipation_traj_file_for_pos = os.path.join(OUTPUT_DIRECTORY, new_dissipated_trajectory_name + '.dcd')

        if {{XTCReporter}} == True:
            print("Decompose started using XTC File")
            reference_traj_file_for_pos = os.path.join(OUTPUT_DIRECTORY, undissipated_trajectory_name + '.xtc')
            dissipation_traj_file_for_pos = os.path.join(OUTPUT_DIRECTORY, new_dissipated_trajectory_name + '.xtc')



    if i == 0:
        position_list, unwrap_pdb = get_openmm_pos_from_traj_with_mdtraj(top=last_pdb_file_path,
                                                                         ref_traj=reference_traj_file_for_pos,
                                                                         modif_traj=dissipation_traj_file_for_pos)


    if i != 0:
        position_list, unwrap_pdb = get_openmm_pos_from_traj_with_mdtraj(top=last_pdb_file_path,
                                                                 ref_traj=None,
                                                                 modif_traj=dissipation_traj_file_for_pos)

     # --> RESIDUE BASED DECOMPOSITION
    if i == 0:
        residue_based_decomposition(topol=unwrap_pdb, trj_pos_list=position_list, start_res=0, stop_res=250,
                                    output_directory=OUTPUT_DIRECTORY, que=__queue,
                                    ref_energy_name='reference_energy_file.csv',
                                    modif_energy_name='modified_energy_file_%s.csv' % int({{speed_factor}}[i]),
                                    origin_last_pdb=last_pdb_file_path, ff='{{protein_ff}}')

    if i != 0:
        # --> RESIDUE BASED DECOMPOSITION
        residue_based_decomposition(topol=unwrap_pdb, trj_pos_list=position_list, start_res=0, stop_res=250,
                                    output_directory=OUTPUT_DIRECTORY, que=__queue,
                                    ref_energy_name=None,
                                    modif_energy_name='modified_energy_file_%s.csv' % int({{speed_factor}}[i]),
                                    origin_last_pdb=last_pdb_file_path,
                                    ff='{{protein_ff}}')

    # --> RESPONSE TIME CSV EXPORTER
    getResidueResponseTimes(os.path.join(OUTPUT_DIRECTORY, 'reference_energy_file.csv'),
                            os.path.join(OUTPUT_DIRECTORY, 'modified_energy_file_%s.csv' % int({{speed_factor}}[i])),
                            outputName=os.path.join(OUTPUT_DIRECTORY, 'responseTimes_%s.csv' % int({{speed_factor}}[i])))


    try:
        del XTC_file_path, ref_simulation, simulation
    except NameError:
        pass




